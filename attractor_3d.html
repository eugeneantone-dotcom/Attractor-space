<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Attractor Particle Space</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }
    .hud{
      position:fixed; left:12px; top:10px; color:#cfcfcf;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      user-select:none; opacity:.9;
      text-shadow: 0 0 8px rgba(0,0,0,.8);
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud" id="hud"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // ======= Tunables =======
  const N = 18000;          // particle count
  const DT = 0.016;         // integration timestep (seconds-ish)
  const DAMP = 0.985;       // velocity damping
  const SPEED_LIMIT = 4.0;  // clamp speed (px/frame)
  const FADE = 0.08;        // trail persistence (higher = shorter trails)
  const EPS = 60.0;         // softening to avoid singularities
  const POWER = 1.35;       // field falloff power (1..2 feels good)
  const SWIRL = 0.65;       // adds a curl-like component around attractors
  const JITTER = 0.12;      // tiny noise to keep motion lively

  // ======= State =======
  let W = 0, H = 0, paused = false;

  // typed arrays for speed
  const px = new Float32Array(N);
  const py = new Float32Array(N);
  const vx = new Float32Array(N);
  const vy = new Float32Array(N);

  // Attractors: {x,y,strength} (positive attracts, negative repels)
  const attractors = [];

  function resize() {
    W = canvas.width  = Math.floor(window.innerWidth * devicePixelRatio);
    H = canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
  }

  function rand(min, max) { return min + Math.random() * (max - min); }

  function seedParticles() {
    for (let i = 0; i < N; i++) {
      px[i] = rand(0, W);
      py[i] = rand(0, H);
      vx[i] = rand(-0.5, 0.5);
      vy[i] = rand(-0.5, 0.5);
    }
  }

  function addAttractor(x, y, strength) {
    attractors.push({ x, y, strength });
  }

  function randomAttractors(k = 4) {
    attractors.length = 0;
    for (let i = 0; i < k; i++) {
      const s = (Math.random() < 0.25 ? -1 : 1) * rand(1800, 5200);
      addAttractor(rand(0.2*W, 0.8*W), rand(0.2*H, 0.8*H), s);
    }
  }

  // Remove nearest attractor within radius
  function removeNearest(x, y) {
    if (!attractors.length) return;
    let best = -1, bestD = Infinity;
    for (let i = 0; i < attractors.length; i++) {
      const dx = attractors[i].x - x, dy = attractors[i].y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD) { bestD = d2; best = i; }
    }
    if (best >= 0 && bestD < (120*devicePixelRatio)*(120*devicePixelRatio)) {
      attractors.splice(best, 1);
    }
  }

  function clearTrails() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
  }

  function drawAttractors() {
    for (const a of attractors) {
      const r = 6 * devicePixelRatio;
      ctx.beginPath();
      ctx.arc(a.x, a.y, r, 0, Math.PI*2);
      ctx.fillStyle = a.strength >= 0 ? 'rgba(120,220,255,0.85)' : 'rgba(255,120,160,0.85)';
      ctx.fill();
    }
  }

  function step() {
    // fade frame (keeps trails)
    ctx.fillStyle = `rgba(0,0,0,${FADE})`;
    ctx.fillRect(0,0,W,H);

    // draw particles as tiny points
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 240, 255, 0.08)';

    const k = attractors.length;

    for (let i = 0; i < N; i++) {
      let ax = 0, ay = 0;

      // sum vector field contributions
      for (let j = 0; j < k; j++) {
        const a = attractors[j];
        const dx = a.x - px[i];
        const dy = a.y - py[i];

        // softened distance
        const d2 = dx*dx + dy*dy + EPS;
        const d = Math.sqrt(d2);

        // inverse power falloff
        const inv = a.strength / Math.pow(d, POWER);

        // base attraction/repulsion
        ax += inv * (dx / (d + 1e-6));
        ay += inv * (dy / (d + 1e-6));

        // swirl (perpendicular) to create curved streamlines
        ax += SWIRL * inv * (-dy / (d + 1e-6));
        ay += SWIRL * inv * ( dx / (d + 1e-6));
      }

      // integrate velocity
      vx[i] = (vx[i] + ax * DT) * DAMP + rand(-JITTER, JITTER);
      vy[i] = (vy[i] + ay * DT) * DAMP + rand(-JITTER, JITTER);

      // clamp speed
      const sp2 = vx[i]*vx[i] + vy[i]*vy[i];
      if (sp2 > SPEED_LIMIT*SPEED_LIMIT) {
        const s = SPEED_LIMIT / Math.sqrt(sp2);
        vx[i] *= s; vy[i] *= s;
      }

      // integrate position
      px[i] += vx[i];
      py[i] += vy[i];

      // wrap edges (nice continuous flow)
      if (px[i] < 0) px[i] += W; else if (px[i] >= W) px[i] -= W;
      if (py[i] < 0) py[i] += H; else if (py[i] >= H) py[i] -= H;

      // draw
      ctx.fillRect(px[i], py[i], 1*devicePixelRatio, 1*devicePixelRatio);
    }

    ctx.globalCompositeOperation = 'source-over';
    drawAttractors();
    updateHUD();
  }

  function updateHUD() {
    const hud = document.getElementById('hud');
    hud.textContent =
`Attractor Particle Space
particles: ${N}
attractors: ${attractors.length}
Click: attractor | Alt+Click: repeller | Shift+Click: remove nearest
R: randomize | Space: pause | C: clear`;
  }

  function loop() {
    if (!paused) step();
    requestAnimationFrame(loop);
  }

  // ======= Events =======
  window.addEventListener('resize', () => {
    resize();
    clearTrails();
    // keep attractors inside bounds after resize
    for (const a of attractors) {
      a.x = Math.max(0, Math.min(W, a.x));
      a.y = Math.max(0, Math.min(H, a.y));
    }
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { paused = !paused; e.preventDefault(); }
    if (e.key.toLowerCase() === 'r') { randomAttractors(4 + (Math.random()*3|0)); }
    if (e.key.toLowerCase() === 'c') { clearTrails(); }
  });

  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * devicePixelRatio;
    const y = (e.clientY - rect.top) * devicePixelRatio;

    if (e.shiftKey) return removeNearest(x, y);

    const strength = (e.altKey ? -1 : 1) * rand(2500, 6500);
    addAttractor(x, y, strength);
  });

  // ======= Init =======
  resize();
  seedParticles();
  randomAttractors(5);
  loop();
})();
</script>
</body>
</html>
