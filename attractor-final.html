<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Strange Attractors (Arcball + UI + Zoom + Scaling + Size)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }
    .ui {
      position: fixed; left: 12px; top: 12px;
      color: #d8d8d8;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      user-select: none;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      width: 360px;
    }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; margin: 7px 0; }
    label { opacity: 0.9; }
    select, input[type="range"], button { font: inherit; }
    select {
      width: 200px;
      background: rgba(0,0,0,0.55);
      color: #d8d8d8;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 8px;
      padding: 4px 6px;
      outline: none;
    }
    input[type="range"] { width: 200px; }
    .btns { display:flex; gap:8px; flex-wrap:wrap; margin-top: 8px; }
    button {
      background: rgba(0,0,0,0.55);
      color: #d8d8d8;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }
    button:hover { border-color: rgba(255,255,255,0.35); }
    .hint { margin-top:8px; opacity:0.8; white-space:pre-line; }
    .val { min-width: 78px; text-align:right; opacity:0.9; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="row">
    <label>Attractor</label>
    <select id="attractor">
      <option value="lorenz">Lorenz</option>
      <option value="rossler">Rössler</option>
      <option value="aizawa">Aizawa</option>
      <option value="thomas">Thomas</option>
    </select>
  </div>

  <div class="row">
    <label>Particles</label>
    <input id="particles" type="range" min="10" max="25000" step="10" value="8000" />
    <div class="val" id="particlesVal">8000</div>
  </div>

  <div class="row">
    <label>Velocity</label>
    <input id="velocity" type="range" min="0.25" max="3.0" step="0.05" value="1.00" />
    <div class="val" id="velocityVal">1.00×</div>
  </div>

  <div class="row">
    <label>Trails</label>
    <input id="trails" type="range" min="0.02" max="0.20" step="0.005" value="0.085" />
    <div class="val" id="trailsVal">0.085</div>
  </div>

  <div class="row">
    <label>Particle Size</label>
    <input id="psize" type="range" min="0.5" max="25.0" step="0.1" value="1.0" />
    <div class="val" id="psizeVal">1.0px</div>
  </div>

  <div class="row">
    <label>Zoom</label>
    <div class="val" id="zoomVal">85.0</div>
  </div>

  <div class="btns">
    <button id="pauseBtn">Pause (Space)</button>
    <button id="resetBtn">Reset</button>
    <button id="clearBtn">Clear Trails</button>
    <button id="homeBtn">Home View</button>
  </div>

  <div class="hint">Rotate: left-click + drag (trackball/arcball)
Zoom: mouse wheel
No pan / no translation
Keys: Space pause, R reset, C clear</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // ---------- Pool ----------
  const MAX_N = 30000;
  let activeN = 8000;

  // ---------- Rendering ----------
  let DPR = 1, W = 0, H = 0;
  let paused = false;

  let FADE = 0.085;
  const LINE_ALPHA = 0.060;

  // Particle "size" (line width of trails)
  let particleSizePx = 1.0;

  // Camera (zoom via wheel modifies camRadius)
  let camRadius = 85;
  const CAM_MIN = 18;
  const CAM_MAX = 260;

  const FOV = 55 * Math.PI/180;
  const NEAR = 0.1;

  // Integration
  let speedMul = 1.0;
  const BASE_H = 0.006;
  const SUBSTEPS = 2;

  // Center lock (centroid)
  const center = {x:0, y:0, z:0};
  const CENTER_SMOOTH = 0.06;

  // Display scaling for non-Lorenz attractors
  const DISPLAY_SCALE = {
    lorenz: 1.0,
    rossler: 6.0,
    aizawa: 28.0,
    thomas: 9.0
  };

  // ---------- State ----------
  const X = new Float32Array(MAX_N);
  const Y = new Float32Array(MAX_N);
  const Z = new Float32Array(MAX_N);

  const PX = new Float32Array(MAX_N);
  const PY = new Float32Array(MAX_N);
  const hasPrev = new Uint8Array(MAX_N);

  let attractorName = 'lorenz';

  // ---------- Utils ----------
  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  function resize() {
    DPR = devicePixelRatio || 1;
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    ctx.setTransform(1,0,0,1,0,0);
    clearTrails();
  }
  function clearTrails() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
  }

  // ---------- Quaternion (arcball) ----------
  function quatIdentity() { return [0,0,0,1]; }
  function quatNormalize(q) {
    const n = Math.hypot(q[0],q[1],q[2],q[3]) || 1;
    q[0]/=n; q[1]/=n; q[2]/=n; q[3]/=n;
    return q;
  }
  function quatMul(a,b) {
    const ax=a[0], ay=a[1], az=a[2], aw=a[3];
    const bx=b[0], by=b[1], bz=b[2], bw=b[3];
    return [
      aw*bx + ax*bw + ay*bz - az*by,
      aw*by - ax*bz + ay*bw + az*bx,
      aw*bz + ax*by - ay*bx + az*bw,
      aw*bw - ax*bx - ay*by - az*bz
    ];
  }
  function quatFromUnitVectors(u, v) {
    const ux=u[0], uy=u[1], uz=u[2];
    const vx=v[0], vy=v[1], vz=v[2];
    const cx = uy*vz - uz*vy;
    const cy = uz*vx - ux*vz;
    const cz = ux*vy - uy*vx;
    const dot = ux*vx + uy*vy + uz*vz;

    if (dot < -0.9999) {
      let ax = Math.abs(ux) < 0.1 ? 1 : 0;
      let ay = Math.abs(uy) < 0.1 ? 1 : 0;
      let az = Math.abs(uz) < 0.1 ? 1 : 0;
      const rx = uy*az - uz*ay;
      const ry = uz*ax - ux*az;
      const rz = ux*ay - uy*ax;
      const rn = Math.hypot(rx,ry,rz) || 1;
      return quatNormalize([rx/rn, ry/rn, rz/rn, 0]);
    }
    return quatNormalize([cx, cy, cz, 1 + dot]);
  }
  function rotateVecByQuat(q, x, y, z) {
    const qx=q[0], qy=q[1], qz=q[2], qw=q[3];
    const tx = 2 * (qy*z - qz*y);
    const ty = 2 * (qz*x - qx*z);
    const tz = 2 * (qx*y - qy*x);
    return [
      x + qw*tx + (qy*tz - qz*ty),
      y + qw*ty + (qz*tx - qx*tz),
      z + qw*tz + (qx*ty - qy*tx)
    ];
  }

  let rotQ = quatIdentity();

  // ---------- Arcball mapping (globe-grab feel) ----------
  function arcballVec(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const cx = rect.left + rect.width * 0.5;
    const cy = rect.top  + rect.height * 0.5;

    const r = 0.92 * Math.min(rect.width, rect.height) * 0.5;
    const x = (clientX - cx) / r;
    const y = (cy - clientY) / r; // down-drag rolls the sphere down

    const d2 = x*x + y*y;
    if (d2 <= 1.0) return [x, y, Math.sqrt(1.0 - d2)];
    const inv = 1.0 / Math.sqrt(d2);
    return [x*inv, y*inv, 0];
  }

  let dragging = false;
  let vDown = [0,0,1];
  let qDown = quatIdentity();

  canvas.addEventListener('pointerdown', (e) => {
    if (e.button !== 0) return;
    dragging = true;
    vDown = arcballVec(e.clientX, e.clientY);
    qDown = rotQ.slice();
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const vNow = arcballVec(e.clientX, e.clientY);
    const dq = quatFromUnitVectors(vDown, vNow);
    rotQ = quatNormalize(quatMul(dq, qDown));
  });

  canvas.addEventListener('pointerup', (e) => {
    dragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  function homeView() { rotQ = quatIdentity(); }

  // ---------- Zoom via wheel ----------
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomSpeed = 0.0022;
    camRadius *= Math.exp(e.deltaY * zoomSpeed);
    camRadius = clamp(camRadius, CAM_MIN, CAM_MAX);
    document.getElementById('zoomVal').textContent = camRadius.toFixed(1);
  }, { passive: false });

  // ---------- Attractor derivatives ----------
  function derivLorenz(x,y,z) {
    const SIGMA=10.0, RHO=28.0, BETA=8/3;
    return [ SIGMA*(y-x), x*(RHO-z)-y, x*y - BETA*z ];
  }
  function derivRossler(x,y,z) {
    const a=0.2, b=0.2, c=5.7;
    return [ -(y+z), x + a*y, b + z*(x-c) ];
  }
  function derivAizawa(x,y,z) {
    const a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1;
    return [
      (z - b)*x - d*y,
      d*x + (z - b)*y,
      c + a*z - (z*z*z)/3 - (x*x + y*y)*(1 + e*z) + f*z*x*x*x
    ];
  }
  function derivThomas(x,y,z) {
    const b=0.208186;
    return [ Math.sin(y)-b*x, Math.sin(z)-b*y, Math.sin(x)-b*z ];
  }
  function deriv(x,y,z) {
    switch(attractorName) {
      case 'rossler': return derivRossler(x,y,z);
      case 'aizawa':  return derivAizawa(x,y,z);
      case 'thomas':  return derivThomas(x,y,z);
      default:        return derivLorenz(x,y,z);
    }
  }

  // ---------- RK4 ----------
  function rk4Step(i, h) {
    const x0=X[i], y0=Y[i], z0=Z[i];

    const k1=deriv(x0,y0,z0);
    const x1=x0+0.5*h*k1[0], y1=y0+0.5*h*k1[1], z1=z0+0.5*h*k1[2];

    const k2=deriv(x1,y1,z1);
    const x2=x0+0.5*h*k2[0], y2=y0+0.5*h*k2[1], z2=z0+0.5*h*k2[2];

    const k3=deriv(x2,y2,z2);
    const x3=x0+h*k3[0], y3=y0+h*k3[1], z3=z0+h*k3[2];

    const k4=deriv(x3,y3,z3);

    X[i]=x0+(h/6)*(k1[0]+2*k2[0]+2*k3[0]+k4[0]);
    Y[i]=y0+(h/6)*(k1[1]+2*k2[1]+2*k3[1]+k4[1]);
    Z[i]=z0+(h/6)*(k1[2]+2*k2[2]+2*k3[2]+k4[2]);
  }

  // ---------- Seeding ----------
  function seedOne(i) {
    if (attractorName === 'lorenz') {
      X[i]=rand(-12,12); Y[i]=rand(-12,12); Z[i]=rand(8,32);
    } else if (attractorName === 'rossler') {
      X[i]=rand(-4,4); Y[i]=rand(-4,4); Z[i]=rand(0,6);
    } else if (attractorName === 'aizawa') {
      X[i]=rand(-1.5,1.5); Y[i]=rand(-1.5,1.5); Z[i]=rand(-0.5,1.5);
    } else { // thomas
      X[i]=rand(-2.5,2.5); Y[i]=rand(-2.5,2.5); Z[i]=rand(-2.5,2.5);
    }
    hasPrev[i]=0;
  }
  function resetParticles(clear=true) {
    center.x=center.y=center.z=0;
    for (let i=0;i<MAX_N;i++) seedOne(i);
    if (clear) clearTrails();
  }
  function ensureNewParticlesSeeded(oldN, newN) {
    for (let i=oldN;i<newN;i++) seedOne(i);
  }

  // ---------- Projection ----------
  function projectPoint(x,y,z) {
    const r = rotateVecByQuat(rotQ, x,y,z);
    const zCam = r[2] + camRadius;
    if (zCam <= NEAR) return null;

    const f = 1 / Math.tan(FOV*0.5);
    const ndcX = (r[0]*f) / zCam;
    const ndcY = (r[1]*f) / zCam;

    return {
      sx: (ndcX*0.5 + 0.5)*W,
      sy: (-ndcY*0.5 + 0.5)*H
    };
  }

  function strokeStyleForAttractor() {
    switch(attractorName) {
      case 'rossler': return `rgba(255, 140, 100, ${LINE_ALPHA})`;
      case 'aizawa':  return `rgba(255, 220, 240, ${LINE_ALPHA})`;
      case 'thomas':  return `rgba(161, 186, 161, ${LINE_ALPHA})`;
      default:        return `rgba(212, 160, 23, ${LINE_ALPHA})`;
    }
  }

  // ---------- Main loop ----------
  function step() {
    ctx.fillStyle = `rgba(0,0,0,${FADE})`;
    ctx.fillRect(0,0,W,H);

    if (!paused) {
      const h = BASE_H * speedMul;
      for (let s=0;s<SUBSTEPS;s++) {
        for (let i=0;i<activeN;i++) rk4Step(i, h);
      }
    }

    // centroid lock
    let mx=0,my=0,mz=0;
    for (let i=0;i<activeN;i++) { mx+=X[i]; my+=Y[i]; mz+=Z[i]; }
    const inv = 1/Math.max(1,activeN);
    mx*=inv; my*=inv; mz*=inv;
    center.x += (mx-center.x)*CENTER_SMOOTH;
    center.y += (my-center.y)*CENTER_SMOOTH;
    center.z += (mz-center.z)*CENTER_SMOOTH;

    const S = DISPLAY_SCALE[attractorName] ?? 1.0;

    ctx.globalCompositeOperation = 'lighter';
    // Particle size slider controls trail thickness:
    ctx.lineWidth = particleSizePx * DPR;
    ctx.beginPath();

    for (let i=0;i<activeN;i++) {
      const x = (X[i]-center.x)*S;
      const y = (Y[i]-center.y)*S;
      const z = (Z[i]-center.z)*S;

      const p = projectPoint(x,y,z);
      if (!p) { hasPrev[i]=0; continue; }

      if (hasPrev[i]) {
        ctx.moveTo(PX[i],PY[i]);
        ctx.lineTo(p.sx,p.sy);
      } else {
        hasPrev[i]=1;
      }
      PX[i]=p.sx; PY[i]=p.sy;
    }

    ctx.strokeStyle = strokeStyleForAttractor();
    ctx.stroke();
    ctx.globalCompositeOperation = 'source-over';
  }

  function loop(){ step(); requestAnimationFrame(loop); }

  // ---------- UI ----------
  const attractorSel = document.getElementById('attractor');
  const particlesSlider = document.getElementById('particles');
  const particlesVal = document.getElementById('particlesVal');
  const velSlider = document.getElementById('velocity');
  const velVal = document.getElementById('velocityVal');
  const trailsSlider = document.getElementById('trails');
  const trailsVal = document.getElementById('trailsVal');

  const psizeSlider = document.getElementById('psize');
  const psizeVal = document.getElementById('psizeVal');

  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const clearBtn = document.getElementById('clearBtn');
  const homeBtn = document.getElementById('homeBtn');

  attractorSel.addEventListener('change', () => {
    attractorName = attractorSel.value;
    resetParticles(true);
  });

  particlesSlider.addEventListener('input', () => {
    const oldN = activeN;
    const newN = clamp(Number(particlesSlider.value), 10, MAX_N);
    activeN = newN;
    particlesVal.textContent = String(activeN);
    if (newN > oldN) ensureNewParticlesSeeded(oldN, newN);
  });

  velSlider.addEventListener('input', () => {
    speedMul = Number(velSlider.value);
    velVal.textContent = speedMul.toFixed(2) + '×';
  });

  trailsSlider.addEventListener('input', () => {
    FADE = Number(trailsSlider.value);
    trailsVal.textContent = FADE.toFixed(3);
  });

  psizeSlider.addEventListener('input', () => {
    particleSizePx = Number(psizeSlider.value);
    psizeVal.textContent = particleSizePx.toFixed(1) + 'px';
  });

  pauseBtn.addEventListener('click', () => { paused = !paused; });
  resetBtn.addEventListener('click', () => resetParticles(true));
  clearBtn.addEventListener('click', () => clearTrails());
  homeBtn.addEventListener('click', () => homeView());

  // Keyboard
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (e.key === ' ') { paused = !paused; e.preventDefault(); }
    if (k === 'r') resetParticles(true);
    if (k === 'c') clearTrails();
  });

  // Init
  window.addEventListener('resize', resize);
  resize();
  resetParticles(true);

  particlesVal.textContent = String(activeN);
  velVal.textContent = speedMul.toFixed(2) + '×';
  trailsVal.textContent = FADE.toFixed(3);
  particleSizePx = Number(psizeSlider.value);
  psizeVal.textContent = particleSizePx.toFixed(1) + 'px';
  document.getElementById('zoomVal').textContent = camRadius.toFixed(1);

  loop();
})();
</script>
</body>
</html>
