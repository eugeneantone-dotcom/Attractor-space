<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Lorenz Attractor (Orbit Rotate)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }
    .hud{
      position:fixed; left:12px; top:10px; color:#cfcfcf;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      user-select:none; opacity:.92;
      text-shadow: 0 0 10px rgba(0,0,0,.9);
      white-space:pre;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud" id="hud"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // ========= Tunables =========
  const N = 7000;                 // particles (raise if your machine is strong)
  const FADE = 0.085;             // trail persistence (higher = shorter trails)
  const LINE_ALPHA = 0.06;        // trail brightness
  const H = 0.006;                // integration dt
  const SUBSTEPS = 2;             // integration substeps per frame
  const JITTER = 0.000;           // optional tiny noise in state-space

  // Lorenz parameters (classic chaotic)
  const SIGMA = 10.0;
  const RHO   = 28.0;
  const BETA  = 8/3;

  // Camera / projection
  let yaw = 0.6;                  // rotate around Y
  let pitch = -0.35;              // rotate around X
  const CAM_RADIUS = 85;          // fixed distance (no linear motion)
  const FOV = 55 * Math.PI/180;   // perspective
  const NEAR = 0.1;

  // ========= State =========
  let W = 0, Hpx = 0, DPR = 1;
  let paused = false;

  // 3D state per particle
  const X = new Float32Array(N);
  const Y = new Float32Array(N);
  const Z = new Float32Array(N);

  // previous 2D projected coords (for trails)
  const PX = new Float32Array(N);
  const PY = new Float32Array(N);
  const PZ = new Float32Array(N); // previous depth (for alpha modulation)
  const hasPrev = new Uint8Array(N);

  function resize() {
    DPR = devicePixelRatio || 1;
    W = canvas.width  = Math.floor(innerWidth  * DPR);
    Hpx = canvas.height = Math.floor(innerHeight * DPR);
    ctx.setTransform(1,0,0,1,0,0);
    clearTrails();
  }

  function clearTrails() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, Hpx);
  }

  function rand(min, max) { return min + Math.random() * (max - min); }

  function resetParticles() {
    // Seed near the Lorenz attractor basin; center is at origin in state-space.
    for (let i = 0; i < N; i++) {
      X[i] = rand(-12, 12);
      Y[i] = rand(-12, 12);
      Z[i] = rand(  8, 32);
      hasPrev[i] = 0;
    }
  }

  // ===== Lorenz derivatives =====
  function lorenzDx(x, y, z) { return SIGMA * (y - x); }
  function lorenzDy(x, y, z) { return x * (RHO - z) - y; }
  function lorenzDz(x, y, z) { return x * y - BETA * z; }

  // ===== RK4 step =====
  function rk4Step(i, h) {
    const x0 = X[i], y0 = Y[i], z0 = Z[i];

    const k1x = lorenzDx(x0,y0,z0);
    const k1y = lorenzDy(x0,y0,z0);
    const k1z = lorenzDz(x0,y0,z0);

    const x1 = x0 + 0.5*h*k1x, y1 = y0 + 0.5*h*k1y, z1 = z0 + 0.5*h*k1z;
    const k2x = lorenzDx(x1,y1,z1);
    const k2y = lorenzDy(x1,y1,z1);
    const k2z = lorenzDz(x1,y1,z1);

    const x2 = x0 + 0.5*h*k2x, y2 = y0 + 0.5*h*k2y, z2 = z0 + 0.5*h*k2z;
    const k3x = lorenzDx(x2,y2,z2);
    const k3y = lorenzDy(x2,y2,z2);
    const k3z = lorenzDz(x2,y2,z2);

    const x3 = x0 + h*k3x, y3 = y0 + h*k3y, z3 = z0 + h*k3z;
    const k4x = lorenzDx(x3,y3,z3);
    const k4y = lorenzDy(x3,y3,z3);
    const k4z = lorenzDz(x3,y3,z3);

    X[i] = x0 + (h/6)*(k1x + 2*k2x + 2*k3x + k4x) + (JITTER ? rand(-JITTER,JITTER) : 0);
    Y[i] = y0 + (h/6)*(k1y + 2*k2y + 2*k3y + k4y) + (JITTER ? rand(-JITTER,JITTER) : 0);
    Z[i] = z0 + (h/6)*(k1z + 2*k2z + 2*k3z + k4z) + (JITTER ? rand(-JITTER,JITTER) : 0);
  }

  // ===== Camera transform (orbit around origin; no translation/pan by user) =====
  function projectPoint(x, y, z) {
    // Rotate world by yaw (Y axis) then pitch (X axis).
    // Equivalent to rotating camera oppositely around origin, with fixed radius.
    const cy = Math.cos(yaw), sy = Math.sin(yaw);
    const cx = Math.cos(pitch), sx = Math.sin(pitch);

    // yaw: around Y
    let x1 =  cy*x + sy*z;
    let y1 =  y;
    let z1 = -sy*x + cy*z;

    // pitch: around X
    let x2 = x1;
    let y2 =  cx*y1 - sx*z1;
    let z2 =  sx*y1 + cx*z1;

    // move camera back (fixed radius). Camera looks toward origin.
    // We can treat this as translating points forward by +CAM_RADIUS in z.
    const zCam = z2 + CAM_RADIUS;

    if (zCam <= NEAR) return null;

    // perspective projection
    const f = 1 / Math.tan(FOV * 0.5);
    const ndcX = (x2 * f) / zCam;
    const ndcY = (y2 * f) / zCam;

    const sx2d = (ndcX * 0.5 + 0.5) * W;
    const sy2d = (-ndcY * 0.5 + 0.5) * Hpx;

    return { sx: sx2d, sy: sy2d, depth: zCam };
  }

  function updateHUD() {
    document.getElementById('hud').textContent =
`3D Lorenz Attractor @ origin (0,0,0)
Particles: ${N}
Rotate: Left-click + drag (yaw/pitch). No pan/translation.
Space: pause | R: reset | C: clear trails`;
  }

  function frame() {
    // fade background
    ctx.fillStyle = `rgba(0,0,0,${FADE})`;
    ctx.fillRect(0,0,W,Hpx);

    // draw trails
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineWidth = 1 * DPR;
    ctx.beginPath();

    if (!paused) {
      for (let s = 0; s < SUBSTEPS; s++) {
        for (let i = 0; i < N; i++) rk4Step(i, H);
      }
    }

    // Draw: line from prev projected position to current.
    // We modulate opacity a bit by depth so near points pop more.
    for (let i = 0; i < N; i++) {
      const p = projectPoint(X[i], Y[i], Z[i]);
      if (!p) { hasPrev[i] = 0; continue; }

      if (hasPrev[i]) {
        // Weâ€™ll draw a lot of segments in one path; cheap + pretty.
        ctx.moveTo(PX[i], PY[i]);
        ctx.lineTo(p.sx, p.sy);
      } else {
        hasPrev[i] = 1;
      }

      PX[i] = p.sx;
      PY[i] = p.sy;
      PZ[i] = p.depth;
    }

    ctx.strokeStyle = `rgba(200, 235, 255, ${LINE_ALPHA})`;
    ctx.stroke();
    ctx.globalCompositeOperation = 'source-over';

    updateHUD();
    requestAnimationFrame(frame);
  }

  // ========= Interaction: rotate only (no translation) =========
  let dragging = false;
  let lastX = 0, lastY = 0;

  canvas.addEventListener('pointerdown', (e) => {
    if (e.button !== 0) return;
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    const sens = 0.0065; // rotation sensitivity
    yaw   += dx * sens;
    pitch += dy * sens;

    // clamp pitch to avoid flipping
    const lim = Math.PI/2 - 0.02;
    if (pitch > lim) pitch = lim;
    if (pitch < -lim) pitch = -lim;
  });

  canvas.addEventListener('pointerup', (e) => {
    dragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (e.key === ' ') { paused = !paused; e.preventDefault(); }
    if (k === 'r') resetParticles();
    if (k === 'c') clearTrails();
  });

  window.addEventListener('resize', resize);

  // ========= Init =========
  resize();
  resetParticles();
  frame();
})();
</script>
</body>
</html>
